// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package orm

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"cloud_platform/iot_model/db_app/model"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newTUcUser(db *gorm.DB) tUcUser {
	_tUcUser := tUcUser{}

	_tUcUser.tUcUserDo.UseDB(db)
	_tUcUser.tUcUserDo.UseModel(&model.TUcUser{})

	tableName := _tUcUser.tUcUserDo.TableName()
	_tUcUser.ALL = field.NewField(tableName, "*")
	_tUcUser.Id = field.NewInt64(tableName, "id")
	_tUcUser.Uid = field.NewString(tableName, "uid")
	_tUcUser.NickName = field.NewString(tableName, "nick_name")
	_tUcUser.Phone = field.NewString(tableName, "phone")
	_tUcUser.Password = field.NewString(tableName, "password")
	_tUcUser.DeviceSecretHttp = field.NewString(tableName, "device_secret_http")
	_tUcUser.DeviceSecretMqtt = field.NewString(tableName, "device_secret_mqtt")
	_tUcUser.Photo = field.NewString(tableName, "photo")
	_tUcUser.UserName = field.NewString(tableName, "user_name")
	_tUcUser.Status = field.NewInt32(tableName, "status")
	_tUcUser.Lang = field.NewString(tableName, "lang")
	_tUcUser.Lat = field.NewFloat64(tableName, "lat")
	_tUcUser.Lng = field.NewFloat64(tableName, "lng")
	_tUcUser.Country = field.NewString(tableName, "country")
	_tUcUser.Province = field.NewString(tableName, "province")
	_tUcUser.City = field.NewString(tableName, "city")
	_tUcUser.District = field.NewString(tableName, "district")
	_tUcUser.Email = field.NewString(tableName, "email")
	_tUcUser.DefaultHomeId = field.NewString(tableName, "default_home_id")
	_tUcUser.Gender = field.NewInt32(tableName, "gender")
	_tUcUser.RegisterRegion = field.NewString(tableName, "register_region")
	_tUcUser.AppOrigin = field.NewString(tableName, "app_origin")
	_tUcUser.AppKey = field.NewString(tableName, "app_key")
	_tUcUser.TenantId = field.NewString(tableName, "tenant_id")
	_tUcUser.CreatedBy = field.NewInt64(tableName, "created_by")
	_tUcUser.UpdatedBy = field.NewInt64(tableName, "updated_by")
	_tUcUser.CancelTime = field.NewInt64(tableName, "cancel_time")
	_tUcUser.LoginTime = field.NewTime(tableName, "login_time")
	_tUcUser.CreatedAt = field.NewTime(tableName, "created_at")
	_tUcUser.UpdatedAt = field.NewTime(tableName, "updated_at")
	_tUcUser.DeletedAt = field.NewField(tableName, "deleted_at")
	_tUcUser.ContactCountry = field.NewString(tableName, "contact_country")
	_tUcUser.ContactArea = field.NewString(tableName, "contact_area")
	_tUcUser.Birthday = field.NewTime(tableName, "birthday")
	_tUcUser.RegionServerId = field.NewInt64(tableName, "region_server_id")
	_tUcUser.UserSalt = field.NewString(tableName, "user_salt")
	_tUcUser.AgreementFlag = field.NewInt32(tableName, "agreement_flag")
	_tUcUser.RegisterRegionId = field.NewInt64(tableName, "register_region_id")

	_tUcUser.fillFieldMap()

	return _tUcUser
}

type tUcUser struct {
	tUcUserDo tUcUserDo

	ALL              field.Field
	Id               field.Int64
	Uid              field.String
	NickName         field.String
	Phone            field.String
	Password         field.String
	DeviceSecretHttp field.String
	DeviceSecretMqtt field.String
	Photo            field.String
	UserName         field.String
	Status           field.Int32
	Lang             field.String
	Lat              field.Float64
	Lng              field.Float64
	Country          field.String
	Province         field.String
	City             field.String
	District         field.String
	Email            field.String
	DefaultHomeId    field.String
	Gender           field.Int32
	RegisterRegion   field.String
	AppOrigin        field.String
	AppKey           field.String
	TenantId         field.String
	CreatedBy        field.Int64
	UpdatedBy        field.Int64
	CancelTime       field.Int64
	LoginTime        field.Time
	CreatedAt        field.Time
	UpdatedAt        field.Time
	DeletedAt        field.Field
	ContactCountry   field.String
	ContactArea      field.String
	Birthday         field.Time
	RegionServerId   field.Int64
	UserSalt         field.String
	AgreementFlag    field.Int32
	RegisterRegionId field.Int64

	fieldMap map[string]field.Expr
}

func (t tUcUser) Table(newTableName string) *tUcUser {
	t.tUcUserDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tUcUser) As(alias string) *tUcUser {
	t.tUcUserDo.DO = *(t.tUcUserDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tUcUser) updateTableName(table string) *tUcUser {
	t.ALL = field.NewField(table, "*")
	t.Id = field.NewInt64(table, "id")
	t.Uid = field.NewString(table, "uid")
	t.NickName = field.NewString(table, "nick_name")
	t.Phone = field.NewString(table, "phone")
	t.Password = field.NewString(table, "password")
	t.DeviceSecretHttp = field.NewString(table, "device_secret_http")
	t.DeviceSecretMqtt = field.NewString(table, "device_secret_mqtt")
	t.Photo = field.NewString(table, "photo")
	t.UserName = field.NewString(table, "user_name")
	t.Status = field.NewInt32(table, "status")
	t.Lang = field.NewString(table, "lang")
	t.Lat = field.NewFloat64(table, "lat")
	t.Lng = field.NewFloat64(table, "lng")
	t.Country = field.NewString(table, "country")
	t.Province = field.NewString(table, "province")
	t.City = field.NewString(table, "city")
	t.District = field.NewString(table, "district")
	t.Email = field.NewString(table, "email")
	t.DefaultHomeId = field.NewString(table, "default_home_id")
	t.Gender = field.NewInt32(table, "gender")
	t.RegisterRegion = field.NewString(table, "register_region")
	t.AppOrigin = field.NewString(table, "app_origin")
	t.AppKey = field.NewString(table, "app_key")
	t.TenantId = field.NewString(table, "tenant_id")
	t.CreatedBy = field.NewInt64(table, "created_by")
	t.UpdatedBy = field.NewInt64(table, "updated_by")
	t.CancelTime = field.NewInt64(table, "cancel_time")
	t.LoginTime = field.NewTime(table, "login_time")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.UpdatedAt = field.NewTime(table, "updated_at")
	t.DeletedAt = field.NewField(table, "deleted_at")
	t.ContactCountry = field.NewString(table, "contact_country")
	t.ContactArea = field.NewString(table, "contact_area")
	t.Birthday = field.NewTime(table, "birthday")
	t.RegionServerId = field.NewInt64(table, "region_server_id")
	t.UserSalt = field.NewString(table, "user_salt")
	t.AgreementFlag = field.NewInt32(table, "agreement_flag")
	t.RegisterRegionId = field.NewInt64(table, "register_region_id")

	t.fillFieldMap()

	return t
}

func (t *tUcUser) WithContext(ctx context.Context) *tUcUserDo { return t.tUcUserDo.WithContext(ctx) }

func (t tUcUser) TableName() string { return t.tUcUserDo.TableName() }

func (t tUcUser) Alias() string { return t.tUcUserDo.Alias() }

func (t *tUcUser) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tUcUser) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 38)
	t.fieldMap["id"] = t.Id
	t.fieldMap["uid"] = t.Uid
	t.fieldMap["nick_name"] = t.NickName
	t.fieldMap["phone"] = t.Phone
	t.fieldMap["password"] = t.Password
	t.fieldMap["device_secret_http"] = t.DeviceSecretHttp
	t.fieldMap["device_secret_mqtt"] = t.DeviceSecretMqtt
	t.fieldMap["photo"] = t.Photo
	t.fieldMap["user_name"] = t.UserName
	t.fieldMap["status"] = t.Status
	t.fieldMap["lang"] = t.Lang
	t.fieldMap["lat"] = t.Lat
	t.fieldMap["lng"] = t.Lng
	t.fieldMap["country"] = t.Country
	t.fieldMap["province"] = t.Province
	t.fieldMap["city"] = t.City
	t.fieldMap["district"] = t.District
	t.fieldMap["email"] = t.Email
	t.fieldMap["default_home_id"] = t.DefaultHomeId
	t.fieldMap["gender"] = t.Gender
	t.fieldMap["register_region"] = t.RegisterRegion
	t.fieldMap["app_origin"] = t.AppOrigin
	t.fieldMap["app_key"] = t.AppKey
	t.fieldMap["tenant_id"] = t.TenantId
	t.fieldMap["created_by"] = t.CreatedBy
	t.fieldMap["updated_by"] = t.UpdatedBy
	t.fieldMap["cancel_time"] = t.CancelTime
	t.fieldMap["login_time"] = t.LoginTime
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["deleted_at"] = t.DeletedAt
	t.fieldMap["contact_country"] = t.ContactCountry
	t.fieldMap["contact_area"] = t.ContactArea
	t.fieldMap["birthday"] = t.Birthday
	t.fieldMap["region_server_id"] = t.RegionServerId
	t.fieldMap["user_salt"] = t.UserSalt
	t.fieldMap["agreement_flag"] = t.AgreementFlag
	t.fieldMap["register_region_id"] = t.RegisterRegionId
}

func (t tUcUser) clone(db *gorm.DB) tUcUser {
	t.tUcUserDo.ReplaceDB(db)
	return t
}

type tUcUserDo struct{ gen.DO }

func (t tUcUserDo) Debug() *tUcUserDo {
	return t.withDO(t.DO.Debug())
}

func (t tUcUserDo) WithContext(ctx context.Context) *tUcUserDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tUcUserDo) Clauses(conds ...clause.Expression) *tUcUserDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tUcUserDo) Returning(value interface{}, columns ...string) *tUcUserDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tUcUserDo) Not(conds ...gen.Condition) *tUcUserDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tUcUserDo) Or(conds ...gen.Condition) *tUcUserDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tUcUserDo) Select(conds ...field.Expr) *tUcUserDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tUcUserDo) Where(conds ...gen.Condition) *tUcUserDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tUcUserDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *tUcUserDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tUcUserDo) Order(conds ...field.Expr) *tUcUserDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tUcUserDo) Distinct(cols ...field.Expr) *tUcUserDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tUcUserDo) Omit(cols ...field.Expr) *tUcUserDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tUcUserDo) Join(table schema.Tabler, on ...field.Expr) *tUcUserDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tUcUserDo) LeftJoin(table schema.Tabler, on ...field.Expr) *tUcUserDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tUcUserDo) RightJoin(table schema.Tabler, on ...field.Expr) *tUcUserDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tUcUserDo) Group(cols ...field.Expr) *tUcUserDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tUcUserDo) Having(conds ...gen.Condition) *tUcUserDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tUcUserDo) Limit(limit int) *tUcUserDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tUcUserDo) Offset(offset int) *tUcUserDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tUcUserDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *tUcUserDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tUcUserDo) Unscoped() *tUcUserDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tUcUserDo) Create(values ...*model.TUcUser) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tUcUserDo) CreateInBatches(values []*model.TUcUser, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tUcUserDo) Save(values ...*model.TUcUser) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tUcUserDo) First() (*model.TUcUser, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUcUser), nil
	}
}

func (t tUcUserDo) Take() (*model.TUcUser, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUcUser), nil
	}
}

func (t tUcUserDo) Last() (*model.TUcUser, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUcUser), nil
	}
}

func (t tUcUserDo) Find() ([]*model.TUcUser, error) {
	result, err := t.DO.Find()
	return result.([]*model.TUcUser), err
}

func (t tUcUserDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TUcUser, err error) {
	buf := make([]*model.TUcUser, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tUcUserDo) FindInBatches(result *[]*model.TUcUser, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tUcUserDo) Attrs(attrs ...field.AssignExpr) *tUcUserDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tUcUserDo) Assign(attrs ...field.AssignExpr) *tUcUserDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tUcUserDo) Joins(field field.RelationField) *tUcUserDo {
	return t.withDO(t.DO.Joins(field))
}

func (t tUcUserDo) Preload(field field.RelationField) *tUcUserDo {
	return t.withDO(t.DO.Preload(field))
}

func (t tUcUserDo) FirstOrInit() (*model.TUcUser, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUcUser), nil
	}
}

func (t tUcUserDo) FirstOrCreate() (*model.TUcUser, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TUcUser), nil
	}
}

func (t tUcUserDo) FindByPage(offset int, limit int) (result []*model.TUcUser, count int64, err error) {
	if limit <= 0 {
		count, err = t.Count()
		return
	}

	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tUcUserDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t *tUcUserDo) withDO(do gen.Dao) *tUcUserDo {
	t.DO = *do.(*gen.DO)
	return t
}
