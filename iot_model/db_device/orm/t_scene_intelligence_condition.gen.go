// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package orm

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"cloud_platform/iot_model/db_device/model"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newTSceneIntelligenceCondition(db *gorm.DB) tSceneIntelligenceCondition {
	_tSceneIntelligenceCondition := tSceneIntelligenceCondition{}

	_tSceneIntelligenceCondition.tSceneIntelligenceConditionDo.UseDB(db)
	_tSceneIntelligenceCondition.tSceneIntelligenceConditionDo.UseModel(&model.TSceneIntelligenceCondition{})

	tableName := _tSceneIntelligenceCondition.tSceneIntelligenceConditionDo.TableName()
	_tSceneIntelligenceCondition.ALL = field.NewField(tableName, "*")
	_tSceneIntelligenceCondition.Id = field.NewInt64(tableName, "id")
	_tSceneIntelligenceCondition.IntelligenceId = field.NewInt64(tableName, "intelligence_id")
	_tSceneIntelligenceCondition.ConditionType = field.NewInt32(tableName, "condition_type")
	_tSceneIntelligenceCondition.Desc = field.NewString(tableName, "desc")
	_tSceneIntelligenceCondition.WeatherCountry = field.NewString(tableName, "weather_country")
	_tSceneIntelligenceCondition.WeatherCity = field.NewString(tableName, "weather_city")
	_tSceneIntelligenceCondition.WeatherArea = field.NewString(tableName, "weather_area")
	_tSceneIntelligenceCondition.WeatherType = field.NewInt32(tableName, "weather_type")
	_tSceneIntelligenceCondition.WeatherValue = field.NewString(tableName, "weather_value")
	_tSceneIntelligenceCondition.WeatherCompare = field.NewInt32(tableName, "weather_compare")
	_tSceneIntelligenceCondition.TimerWeeks = field.NewString(tableName, "timer_weeks")
	_tSceneIntelligenceCondition.TimerValue = field.NewString(tableName, "timer_value")
	_tSceneIntelligenceCondition.DeviceDid = field.NewString(tableName, "device_did")
	_tSceneIntelligenceCondition.DevicePropKey = field.NewString(tableName, "device_prop_key")
	_tSceneIntelligenceCondition.DevicePropCompare = field.NewInt32(tableName, "device_prop_compare")
	_tSceneIntelligenceCondition.DevicePropValue = field.NewString(tableName, "device_prop_value")
	_tSceneIntelligenceCondition.ProductId = field.NewInt64(tableName, "product_id")
	_tSceneIntelligenceCondition.ProductKey = field.NewString(tableName, "product_key")
	_tSceneIntelligenceCondition.Sort = field.NewInt32(tableName, "sort")
	_tSceneIntelligenceCondition.DevicePropIdentifier = field.NewString(tableName, "device_prop_identifier")
	_tSceneIntelligenceCondition.DevicePropDesc = field.NewString(tableName, "device_prop_desc")

	_tSceneIntelligenceCondition.fillFieldMap()

	return _tSceneIntelligenceCondition
}

type tSceneIntelligenceCondition struct {
	tSceneIntelligenceConditionDo tSceneIntelligenceConditionDo

	ALL                  field.Field
	Id                   field.Int64
	IntelligenceId       field.Int64
	ConditionType        field.Int32
	Desc                 field.String
	WeatherCountry       field.String
	WeatherCity          field.String
	WeatherArea          field.String
	WeatherType          field.Int32
	WeatherValue         field.String
	WeatherCompare       field.Int32
	TimerWeeks           field.String
	TimerValue           field.String
	DeviceDid            field.String
	DevicePropKey        field.String
	DevicePropCompare    field.Int32
	DevicePropValue      field.String
	ProductId            field.Int64
	ProductKey           field.String
	Sort                 field.Int32
	DevicePropIdentifier field.String
	DevicePropDesc       field.String

	fieldMap map[string]field.Expr
}

func (t tSceneIntelligenceCondition) Table(newTableName string) *tSceneIntelligenceCondition {
	t.tSceneIntelligenceConditionDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tSceneIntelligenceCondition) As(alias string) *tSceneIntelligenceCondition {
	t.tSceneIntelligenceConditionDo.DO = *(t.tSceneIntelligenceConditionDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tSceneIntelligenceCondition) updateTableName(table string) *tSceneIntelligenceCondition {
	t.ALL = field.NewField(table, "*")
	t.Id = field.NewInt64(table, "id")
	t.IntelligenceId = field.NewInt64(table, "intelligence_id")
	t.ConditionType = field.NewInt32(table, "condition_type")
	t.Desc = field.NewString(table, "desc")
	t.WeatherCountry = field.NewString(table, "weather_country")
	t.WeatherCity = field.NewString(table, "weather_city")
	t.WeatherArea = field.NewString(table, "weather_area")
	t.WeatherType = field.NewInt32(table, "weather_type")
	t.WeatherValue = field.NewString(table, "weather_value")
	t.WeatherCompare = field.NewInt32(table, "weather_compare")
	t.TimerWeeks = field.NewString(table, "timer_weeks")
	t.TimerValue = field.NewString(table, "timer_value")
	t.DeviceDid = field.NewString(table, "device_did")
	t.DevicePropKey = field.NewString(table, "device_prop_key")
	t.DevicePropCompare = field.NewInt32(table, "device_prop_compare")
	t.DevicePropValue = field.NewString(table, "device_prop_value")
	t.ProductId = field.NewInt64(table, "product_id")
	t.ProductKey = field.NewString(table, "product_key")
	t.Sort = field.NewInt32(table, "sort")
	t.DevicePropIdentifier = field.NewString(table, "device_prop_identifier")
	t.DevicePropDesc = field.NewString(table, "device_prop_desc")

	t.fillFieldMap()

	return t
}

func (t *tSceneIntelligenceCondition) WithContext(ctx context.Context) *tSceneIntelligenceConditionDo {
	return t.tSceneIntelligenceConditionDo.WithContext(ctx)
}

func (t tSceneIntelligenceCondition) TableName() string {
	return t.tSceneIntelligenceConditionDo.TableName()
}

func (t tSceneIntelligenceCondition) Alias() string { return t.tSceneIntelligenceConditionDo.Alias() }

func (t *tSceneIntelligenceCondition) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tSceneIntelligenceCondition) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 21)
	t.fieldMap["id"] = t.Id
	t.fieldMap["intelligence_id"] = t.IntelligenceId
	t.fieldMap["condition_type"] = t.ConditionType
	t.fieldMap["desc"] = t.Desc
	t.fieldMap["weather_country"] = t.WeatherCountry
	t.fieldMap["weather_city"] = t.WeatherCity
	t.fieldMap["weather_area"] = t.WeatherArea
	t.fieldMap["weather_type"] = t.WeatherType
	t.fieldMap["weather_value"] = t.WeatherValue
	t.fieldMap["weather_compare"] = t.WeatherCompare
	t.fieldMap["timer_weeks"] = t.TimerWeeks
	t.fieldMap["timer_value"] = t.TimerValue
	t.fieldMap["device_did"] = t.DeviceDid
	t.fieldMap["device_prop_key"] = t.DevicePropKey
	t.fieldMap["device_prop_compare"] = t.DevicePropCompare
	t.fieldMap["device_prop_value"] = t.DevicePropValue
	t.fieldMap["product_id"] = t.ProductId
	t.fieldMap["product_key"] = t.ProductKey
	t.fieldMap["sort"] = t.Sort
	t.fieldMap["device_prop_identifier"] = t.DevicePropIdentifier
	t.fieldMap["device_prop_desc"] = t.DevicePropDesc
}

func (t tSceneIntelligenceCondition) clone(db *gorm.DB) tSceneIntelligenceCondition {
	t.tSceneIntelligenceConditionDo.ReplaceDB(db)
	return t
}

type tSceneIntelligenceConditionDo struct{ gen.DO }

func (t tSceneIntelligenceConditionDo) Debug() *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Debug())
}

func (t tSceneIntelligenceConditionDo) WithContext(ctx context.Context) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tSceneIntelligenceConditionDo) Clauses(conds ...clause.Expression) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tSceneIntelligenceConditionDo) Returning(value interface{}, columns ...string) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tSceneIntelligenceConditionDo) Not(conds ...gen.Condition) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tSceneIntelligenceConditionDo) Or(conds ...gen.Condition) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tSceneIntelligenceConditionDo) Select(conds ...field.Expr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tSceneIntelligenceConditionDo) Where(conds ...gen.Condition) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tSceneIntelligenceConditionDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *tSceneIntelligenceConditionDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tSceneIntelligenceConditionDo) Order(conds ...field.Expr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tSceneIntelligenceConditionDo) Distinct(cols ...field.Expr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tSceneIntelligenceConditionDo) Omit(cols ...field.Expr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tSceneIntelligenceConditionDo) Join(table schema.Tabler, on ...field.Expr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tSceneIntelligenceConditionDo) LeftJoin(table schema.Tabler, on ...field.Expr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tSceneIntelligenceConditionDo) RightJoin(table schema.Tabler, on ...field.Expr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tSceneIntelligenceConditionDo) Group(cols ...field.Expr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tSceneIntelligenceConditionDo) Having(conds ...gen.Condition) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tSceneIntelligenceConditionDo) Limit(limit int) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tSceneIntelligenceConditionDo) Offset(offset int) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tSceneIntelligenceConditionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tSceneIntelligenceConditionDo) Unscoped() *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tSceneIntelligenceConditionDo) Create(values ...*model.TSceneIntelligenceCondition) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tSceneIntelligenceConditionDo) CreateInBatches(values []*model.TSceneIntelligenceCondition, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tSceneIntelligenceConditionDo) Save(values ...*model.TSceneIntelligenceCondition) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tSceneIntelligenceConditionDo) First() (*model.TSceneIntelligenceCondition, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSceneIntelligenceCondition), nil
	}
}

func (t tSceneIntelligenceConditionDo) Take() (*model.TSceneIntelligenceCondition, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSceneIntelligenceCondition), nil
	}
}

func (t tSceneIntelligenceConditionDo) Last() (*model.TSceneIntelligenceCondition, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSceneIntelligenceCondition), nil
	}
}

func (t tSceneIntelligenceConditionDo) Find() ([]*model.TSceneIntelligenceCondition, error) {
	result, err := t.DO.Find()
	return result.([]*model.TSceneIntelligenceCondition), err
}

func (t tSceneIntelligenceConditionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TSceneIntelligenceCondition, err error) {
	buf := make([]*model.TSceneIntelligenceCondition, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tSceneIntelligenceConditionDo) FindInBatches(result *[]*model.TSceneIntelligenceCondition, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tSceneIntelligenceConditionDo) Attrs(attrs ...field.AssignExpr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tSceneIntelligenceConditionDo) Assign(attrs ...field.AssignExpr) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tSceneIntelligenceConditionDo) Joins(field field.RelationField) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Joins(field))
}

func (t tSceneIntelligenceConditionDo) Preload(field field.RelationField) *tSceneIntelligenceConditionDo {
	return t.withDO(t.DO.Preload(field))
}

func (t tSceneIntelligenceConditionDo) FirstOrInit() (*model.TSceneIntelligenceCondition, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSceneIntelligenceCondition), nil
	}
}

func (t tSceneIntelligenceConditionDo) FirstOrCreate() (*model.TSceneIntelligenceCondition, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TSceneIntelligenceCondition), nil
	}
}

func (t tSceneIntelligenceConditionDo) FindByPage(offset int, limit int) (result []*model.TSceneIntelligenceCondition, count int64, err error) {
	if limit <= 0 {
		count, err = t.Count()
		return
	}

	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tSceneIntelligenceConditionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t *tSceneIntelligenceConditionDo) withDO(do gen.Dao) *tSceneIntelligenceConditionDo {
	t.DO = *do.(*gen.DO)
	return t
}
