// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package orm

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"cloud_platform/iot_model/db_product/model"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newTOpmLocalScene(db *gorm.DB) tOpmLocalScene {
	_tOpmLocalScene := tOpmLocalScene{}

	_tOpmLocalScene.tOpmLocalSceneDo.UseDB(db)
	_tOpmLocalScene.tOpmLocalSceneDo.UseModel(&model.TOpmLocalScene{})

	tableName := _tOpmLocalScene.tOpmLocalSceneDo.TableName()
	_tOpmLocalScene.ALL = field.NewField(tableName, "*")
	_tOpmLocalScene.Id = field.NewInt64(tableName, "id")
	_tOpmLocalScene.Title = field.NewString(tableName, "title")
	_tOpmLocalScene.SubTitle = field.NewString(tableName, "sub_title")
	_tOpmLocalScene.Desc = field.NewString(tableName, "desc")
	_tOpmLocalScene.SortNo = field.NewInt32(tableName, "sort_no")
	_tOpmLocalScene.Status = field.NewInt32(tableName, "status")
	_tOpmLocalScene.ImageUrl = field.NewString(tableName, "image_url")
	_tOpmLocalScene.VideoUrl = field.NewString(tableName, "video_url")
	_tOpmLocalScene.VideoName = field.NewString(tableName, "video_name")
	_tOpmLocalScene.VideoKey = field.NewString(tableName, "video_key")
	_tOpmLocalScene.VideoSize = field.NewInt32(tableName, "video_size")
	_tOpmLocalScene.AudioUrl = field.NewString(tableName, "audio_url")
	_tOpmLocalScene.AudioName = field.NewString(tableName, "audio_name")
	_tOpmLocalScene.AudioKey = field.NewString(tableName, "audio_key")
	_tOpmLocalScene.AudioSize = field.NewInt32(tableName, "audio_size")
	_tOpmLocalScene.AudioEnUrl = field.NewString(tableName, "audio_en_url")
	_tOpmLocalScene.AudioEnName = field.NewString(tableName, "audio_en_name")
	_tOpmLocalScene.AudioEnKey = field.NewString(tableName, "audio_en_key")
	_tOpmLocalScene.AudioEnSize = field.NewInt32(tableName, "audio_en_size")
	_tOpmLocalScene.UseMode = field.NewInt32(tableName, "use_mode")
	_tOpmLocalScene.Classify = field.NewInt64(tableName, "classify")
	_tOpmLocalScene.OpenMode = field.NewString(tableName, "open_mode")
	_tOpmLocalScene.IsCycle = field.NewInt32(tableName, "is_cycle")
	_tOpmLocalScene.RunningTime = field.NewInt32(tableName, "running_time")
	_tOpmLocalScene.Timer = field.NewString(tableName, "timer")
	_tOpmLocalScene.CreatedBy = field.NewInt64(tableName, "created_by")
	_tOpmLocalScene.UpdatedBy = field.NewInt64(tableName, "updated_by")
	_tOpmLocalScene.CreatedAt = field.NewTime(tableName, "created_at")
	_tOpmLocalScene.UpdatedAt = field.NewTime(tableName, "updated_at")
	_tOpmLocalScene.DeletedAt = field.NewField(tableName, "deleted_at")
	_tOpmLocalScene.TenantId = field.NewString(tableName, "tenant_id")
	_tOpmLocalScene.IsSpecifyApp = field.NewInt32(tableName, "is_specify_app")

	_tOpmLocalScene.fillFieldMap()

	return _tOpmLocalScene
}

type tOpmLocalScene struct {
	tOpmLocalSceneDo tOpmLocalSceneDo

	ALL          field.Field
	Id           field.Int64
	Title        field.String
	SubTitle     field.String
	Desc         field.String
	SortNo       field.Int32
	Status       field.Int32
	ImageUrl     field.String
	VideoUrl     field.String
	VideoName    field.String
	VideoKey     field.String
	VideoSize    field.Int32
	AudioUrl     field.String
	AudioName    field.String
	AudioKey     field.String
	AudioSize    field.Int32
	AudioEnUrl   field.String
	AudioEnName  field.String
	AudioEnKey   field.String
	AudioEnSize  field.Int32
	UseMode      field.Int32
	Classify     field.Int64
	OpenMode     field.String
	IsCycle      field.Int32
	RunningTime  field.Int32
	Timer        field.String
	CreatedBy    field.Int64
	UpdatedBy    field.Int64
	CreatedAt    field.Time
	UpdatedAt    field.Time
	DeletedAt    field.Field
	TenantId     field.String
	IsSpecifyApp field.Int32

	fieldMap map[string]field.Expr
}

func (t tOpmLocalScene) Table(newTableName string) *tOpmLocalScene {
	t.tOpmLocalSceneDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tOpmLocalScene) As(alias string) *tOpmLocalScene {
	t.tOpmLocalSceneDo.DO = *(t.tOpmLocalSceneDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tOpmLocalScene) updateTableName(table string) *tOpmLocalScene {
	t.ALL = field.NewField(table, "*")
	t.Id = field.NewInt64(table, "id")
	t.Title = field.NewString(table, "title")
	t.SubTitle = field.NewString(table, "sub_title")
	t.Desc = field.NewString(table, "desc")
	t.SortNo = field.NewInt32(table, "sort_no")
	t.Status = field.NewInt32(table, "status")
	t.ImageUrl = field.NewString(table, "image_url")
	t.VideoUrl = field.NewString(table, "video_url")
	t.VideoName = field.NewString(table, "video_name")
	t.VideoKey = field.NewString(table, "video_key")
	t.VideoSize = field.NewInt32(table, "video_size")
	t.AudioUrl = field.NewString(table, "audio_url")
	t.AudioName = field.NewString(table, "audio_name")
	t.AudioKey = field.NewString(table, "audio_key")
	t.AudioSize = field.NewInt32(table, "audio_size")
	t.AudioEnUrl = field.NewString(table, "audio_en_url")
	t.AudioEnName = field.NewString(table, "audio_en_name")
	t.AudioEnKey = field.NewString(table, "audio_en_key")
	t.AudioEnSize = field.NewInt32(table, "audio_en_size")
	t.UseMode = field.NewInt32(table, "use_mode")
	t.Classify = field.NewInt64(table, "classify")
	t.OpenMode = field.NewString(table, "open_mode")
	t.IsCycle = field.NewInt32(table, "is_cycle")
	t.RunningTime = field.NewInt32(table, "running_time")
	t.Timer = field.NewString(table, "timer")
	t.CreatedBy = field.NewInt64(table, "created_by")
	t.UpdatedBy = field.NewInt64(table, "updated_by")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.UpdatedAt = field.NewTime(table, "updated_at")
	t.DeletedAt = field.NewField(table, "deleted_at")
	t.TenantId = field.NewString(table, "tenant_id")
	t.IsSpecifyApp = field.NewInt32(table, "is_specify_app")

	t.fillFieldMap()

	return t
}

func (t *tOpmLocalScene) WithContext(ctx context.Context) *tOpmLocalSceneDo {
	return t.tOpmLocalSceneDo.WithContext(ctx)
}

func (t tOpmLocalScene) TableName() string { return t.tOpmLocalSceneDo.TableName() }

func (t tOpmLocalScene) Alias() string { return t.tOpmLocalSceneDo.Alias() }

func (t *tOpmLocalScene) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tOpmLocalScene) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 32)
	t.fieldMap["id"] = t.Id
	t.fieldMap["title"] = t.Title
	t.fieldMap["sub_title"] = t.SubTitle
	t.fieldMap["desc"] = t.Desc
	t.fieldMap["sort_no"] = t.SortNo
	t.fieldMap["status"] = t.Status
	t.fieldMap["image_url"] = t.ImageUrl
	t.fieldMap["video_url"] = t.VideoUrl
	t.fieldMap["video_name"] = t.VideoName
	t.fieldMap["video_key"] = t.VideoKey
	t.fieldMap["video_size"] = t.VideoSize
	t.fieldMap["audio_url"] = t.AudioUrl
	t.fieldMap["audio_name"] = t.AudioName
	t.fieldMap["audio_key"] = t.AudioKey
	t.fieldMap["audio_size"] = t.AudioSize
	t.fieldMap["audio_en_url"] = t.AudioEnUrl
	t.fieldMap["audio_en_name"] = t.AudioEnName
	t.fieldMap["audio_en_key"] = t.AudioEnKey
	t.fieldMap["audio_en_size"] = t.AudioEnSize
	t.fieldMap["use_mode"] = t.UseMode
	t.fieldMap["classify"] = t.Classify
	t.fieldMap["open_mode"] = t.OpenMode
	t.fieldMap["is_cycle"] = t.IsCycle
	t.fieldMap["running_time"] = t.RunningTime
	t.fieldMap["timer"] = t.Timer
	t.fieldMap["created_by"] = t.CreatedBy
	t.fieldMap["updated_by"] = t.UpdatedBy
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["deleted_at"] = t.DeletedAt
	t.fieldMap["tenant_id"] = t.TenantId
	t.fieldMap["is_specify_app"] = t.IsSpecifyApp
}

func (t tOpmLocalScene) clone(db *gorm.DB) tOpmLocalScene {
	t.tOpmLocalSceneDo.ReplaceDB(db)
	return t
}

type tOpmLocalSceneDo struct{ gen.DO }

func (t tOpmLocalSceneDo) Debug() *tOpmLocalSceneDo {
	return t.withDO(t.DO.Debug())
}

func (t tOpmLocalSceneDo) WithContext(ctx context.Context) *tOpmLocalSceneDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tOpmLocalSceneDo) Clauses(conds ...clause.Expression) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tOpmLocalSceneDo) Returning(value interface{}, columns ...string) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tOpmLocalSceneDo) Not(conds ...gen.Condition) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tOpmLocalSceneDo) Or(conds ...gen.Condition) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tOpmLocalSceneDo) Select(conds ...field.Expr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tOpmLocalSceneDo) Where(conds ...gen.Condition) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tOpmLocalSceneDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *tOpmLocalSceneDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tOpmLocalSceneDo) Order(conds ...field.Expr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tOpmLocalSceneDo) Distinct(cols ...field.Expr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tOpmLocalSceneDo) Omit(cols ...field.Expr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tOpmLocalSceneDo) Join(table schema.Tabler, on ...field.Expr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tOpmLocalSceneDo) LeftJoin(table schema.Tabler, on ...field.Expr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tOpmLocalSceneDo) RightJoin(table schema.Tabler, on ...field.Expr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tOpmLocalSceneDo) Group(cols ...field.Expr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tOpmLocalSceneDo) Having(conds ...gen.Condition) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tOpmLocalSceneDo) Limit(limit int) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tOpmLocalSceneDo) Offset(offset int) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tOpmLocalSceneDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tOpmLocalSceneDo) Unscoped() *tOpmLocalSceneDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tOpmLocalSceneDo) Create(values ...*model.TOpmLocalScene) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tOpmLocalSceneDo) CreateInBatches(values []*model.TOpmLocalScene, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tOpmLocalSceneDo) Save(values ...*model.TOpmLocalScene) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tOpmLocalSceneDo) First() (*model.TOpmLocalScene, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TOpmLocalScene), nil
	}
}

func (t tOpmLocalSceneDo) Take() (*model.TOpmLocalScene, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TOpmLocalScene), nil
	}
}

func (t tOpmLocalSceneDo) Last() (*model.TOpmLocalScene, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TOpmLocalScene), nil
	}
}

func (t tOpmLocalSceneDo) Find() ([]*model.TOpmLocalScene, error) {
	result, err := t.DO.Find()
	return result.([]*model.TOpmLocalScene), err
}

func (t tOpmLocalSceneDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TOpmLocalScene, err error) {
	buf := make([]*model.TOpmLocalScene, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tOpmLocalSceneDo) FindInBatches(result *[]*model.TOpmLocalScene, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tOpmLocalSceneDo) Attrs(attrs ...field.AssignExpr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tOpmLocalSceneDo) Assign(attrs ...field.AssignExpr) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tOpmLocalSceneDo) Joins(field field.RelationField) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Joins(field))
}

func (t tOpmLocalSceneDo) Preload(field field.RelationField) *tOpmLocalSceneDo {
	return t.withDO(t.DO.Preload(field))
}

func (t tOpmLocalSceneDo) FirstOrInit() (*model.TOpmLocalScene, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TOpmLocalScene), nil
	}
}

func (t tOpmLocalSceneDo) FirstOrCreate() (*model.TOpmLocalScene, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TOpmLocalScene), nil
	}
}

func (t tOpmLocalSceneDo) FindByPage(offset int, limit int) (result []*model.TOpmLocalScene, count int64, err error) {
	if limit <= 0 {
		count, err = t.Count()
		return
	}

	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tOpmLocalSceneDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t *tOpmLocalSceneDo) withDO(do gen.Dao) *tOpmLocalSceneDo {
	t.DO = *do.(*gen.DO)
	return t
}
