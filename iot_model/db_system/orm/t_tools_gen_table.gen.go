// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package orm

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"cloud_platform/iot_model/db_system/model"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newTToolsGenTable(db *gorm.DB) tToolsGenTable {
	_tToolsGenTable := tToolsGenTable{}

	_tToolsGenTable.tToolsGenTableDo.UseDB(db)
	_tToolsGenTable.tToolsGenTableDo.UseModel(&model.TToolsGenTable{})

	tableName := _tToolsGenTable.tToolsGenTableDo.TableName()
	_tToolsGenTable.ALL = field.NewField(tableName, "*")
	_tToolsGenTable.TableId = field.NewInt64(tableName, "table_id")
	_tToolsGenTable.TableNameE = field.NewString(tableName, "table_name_e")
	_tToolsGenTable.TableComment = field.NewString(tableName, "table_comment")
	_tToolsGenTable.ClassName = field.NewString(tableName, "class_name")
	_tToolsGenTable.TplCategory = field.NewString(tableName, "tpl_category")
	_tToolsGenTable.PackageName = field.NewString(tableName, "package_name")
	_tToolsGenTable.ModuleName = field.NewString(tableName, "module_name")
	_tToolsGenTable.BusinessName = field.NewString(tableName, "business_name")
	_tToolsGenTable.FunctionName = field.NewString(tableName, "function_name")
	_tToolsGenTable.FunctionAuthor = field.NewString(tableName, "function_author")
	_tToolsGenTable.Options = field.NewString(tableName, "options")
	_tToolsGenTable.CreateTime = field.NewTime(tableName, "create_time")
	_tToolsGenTable.UpdateTime = field.NewTime(tableName, "update_time")
	_tToolsGenTable.Remark = field.NewString(tableName, "remark")

	_tToolsGenTable.fillFieldMap()

	return _tToolsGenTable
}

type tToolsGenTable struct {
	tToolsGenTableDo tToolsGenTableDo

	ALL            field.Field
	TableId        field.Int64
	TableNameE     field.String
	TableComment   field.String
	ClassName      field.String
	TplCategory    field.String
	PackageName    field.String
	ModuleName     field.String
	BusinessName   field.String
	FunctionName   field.String
	FunctionAuthor field.String
	Options        field.String
	CreateTime     field.Time
	UpdateTime     field.Time
	Remark         field.String

	fieldMap map[string]field.Expr
}

func (t tToolsGenTable) Table(newTableName string) *tToolsGenTable {
	t.tToolsGenTableDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tToolsGenTable) As(alias string) *tToolsGenTable {
	t.tToolsGenTableDo.DO = *(t.tToolsGenTableDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tToolsGenTable) updateTableName(table string) *tToolsGenTable {
	t.ALL = field.NewField(table, "*")
	t.TableId = field.NewInt64(table, "table_id")
	t.TableNameE = field.NewString(table, "table_name_e")
	t.TableComment = field.NewString(table, "table_comment")
	t.ClassName = field.NewString(table, "class_name")
	t.TplCategory = field.NewString(table, "tpl_category")
	t.PackageName = field.NewString(table, "package_name")
	t.ModuleName = field.NewString(table, "module_name")
	t.BusinessName = field.NewString(table, "business_name")
	t.FunctionName = field.NewString(table, "function_name")
	t.FunctionAuthor = field.NewString(table, "function_author")
	t.Options = field.NewString(table, "options")
	t.CreateTime = field.NewTime(table, "create_time")
	t.UpdateTime = field.NewTime(table, "update_time")
	t.Remark = field.NewString(table, "remark")

	t.fillFieldMap()

	return t
}

func (t *tToolsGenTable) WithContext(ctx context.Context) *tToolsGenTableDo {
	return t.tToolsGenTableDo.WithContext(ctx)
}

func (t tToolsGenTable) TableName() string { return t.tToolsGenTableDo.TableName() }

func (t tToolsGenTable) Alias() string { return t.tToolsGenTableDo.Alias() }

func (t *tToolsGenTable) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tToolsGenTable) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 14)
	t.fieldMap["table_id"] = t.TableId
	t.fieldMap["table_name_e"] = t.TableNameE
	t.fieldMap["table_comment"] = t.TableComment
	t.fieldMap["class_name"] = t.ClassName
	t.fieldMap["tpl_category"] = t.TplCategory
	t.fieldMap["package_name"] = t.PackageName
	t.fieldMap["module_name"] = t.ModuleName
	t.fieldMap["business_name"] = t.BusinessName
	t.fieldMap["function_name"] = t.FunctionName
	t.fieldMap["function_author"] = t.FunctionAuthor
	t.fieldMap["options"] = t.Options
	t.fieldMap["create_time"] = t.CreateTime
	t.fieldMap["update_time"] = t.UpdateTime
	t.fieldMap["remark"] = t.Remark
}

func (t tToolsGenTable) clone(db *gorm.DB) tToolsGenTable {
	t.tToolsGenTableDo.ReplaceDB(db)
	return t
}

type tToolsGenTableDo struct{ gen.DO }

func (t tToolsGenTableDo) Debug() *tToolsGenTableDo {
	return t.withDO(t.DO.Debug())
}

func (t tToolsGenTableDo) WithContext(ctx context.Context) *tToolsGenTableDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tToolsGenTableDo) Clauses(conds ...clause.Expression) *tToolsGenTableDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tToolsGenTableDo) Returning(value interface{}, columns ...string) *tToolsGenTableDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tToolsGenTableDo) Not(conds ...gen.Condition) *tToolsGenTableDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tToolsGenTableDo) Or(conds ...gen.Condition) *tToolsGenTableDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tToolsGenTableDo) Select(conds ...field.Expr) *tToolsGenTableDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tToolsGenTableDo) Where(conds ...gen.Condition) *tToolsGenTableDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tToolsGenTableDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *tToolsGenTableDo {
	return t.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (t tToolsGenTableDo) Order(conds ...field.Expr) *tToolsGenTableDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tToolsGenTableDo) Distinct(cols ...field.Expr) *tToolsGenTableDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tToolsGenTableDo) Omit(cols ...field.Expr) *tToolsGenTableDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tToolsGenTableDo) Join(table schema.Tabler, on ...field.Expr) *tToolsGenTableDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tToolsGenTableDo) LeftJoin(table schema.Tabler, on ...field.Expr) *tToolsGenTableDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tToolsGenTableDo) RightJoin(table schema.Tabler, on ...field.Expr) *tToolsGenTableDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tToolsGenTableDo) Group(cols ...field.Expr) *tToolsGenTableDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tToolsGenTableDo) Having(conds ...gen.Condition) *tToolsGenTableDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tToolsGenTableDo) Limit(limit int) *tToolsGenTableDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tToolsGenTableDo) Offset(offset int) *tToolsGenTableDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tToolsGenTableDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *tToolsGenTableDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tToolsGenTableDo) Unscoped() *tToolsGenTableDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tToolsGenTableDo) Create(values ...*model.TToolsGenTable) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tToolsGenTableDo) CreateInBatches(values []*model.TToolsGenTable, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tToolsGenTableDo) Save(values ...*model.TToolsGenTable) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tToolsGenTableDo) First() (*model.TToolsGenTable, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TToolsGenTable), nil
	}
}

func (t tToolsGenTableDo) Take() (*model.TToolsGenTable, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TToolsGenTable), nil
	}
}

func (t tToolsGenTableDo) Last() (*model.TToolsGenTable, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TToolsGenTable), nil
	}
}

func (t tToolsGenTableDo) Find() ([]*model.TToolsGenTable, error) {
	result, err := t.DO.Find()
	return result.([]*model.TToolsGenTable), err
}

func (t tToolsGenTableDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TToolsGenTable, err error) {
	buf := make([]*model.TToolsGenTable, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tToolsGenTableDo) FindInBatches(result *[]*model.TToolsGenTable, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tToolsGenTableDo) Attrs(attrs ...field.AssignExpr) *tToolsGenTableDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tToolsGenTableDo) Assign(attrs ...field.AssignExpr) *tToolsGenTableDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tToolsGenTableDo) Joins(field field.RelationField) *tToolsGenTableDo {
	return t.withDO(t.DO.Joins(field))
}

func (t tToolsGenTableDo) Preload(field field.RelationField) *tToolsGenTableDo {
	return t.withDO(t.DO.Preload(field))
}

func (t tToolsGenTableDo) FirstOrInit() (*model.TToolsGenTable, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TToolsGenTable), nil
	}
}

func (t tToolsGenTableDo) FirstOrCreate() (*model.TToolsGenTable, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TToolsGenTable), nil
	}
}

func (t tToolsGenTableDo) FindByPage(offset int, limit int) (result []*model.TToolsGenTable, count int64, err error) {
	if limit <= 0 {
		count, err = t.Count()
		return
	}

	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tToolsGenTableDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t *tToolsGenTableDo) withDO(do gen.Dao) *tToolsGenTableDo {
	t.DO = *do.(*gen.DO)
	return t
}
